(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{373:function(a,t,v){"use strict";v.r(t);var s=v(49),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"javascript-性能优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javascript-性能优化"}},[a._v("#")]),a._v(" JavaScript 性能优化")]),a._v(" "),v("div",{staticClass:"custom-block danger"},[v("p",{staticClass:"custom-block-title"},[a._v("重要提示")]),a._v(" "),v("p",[a._v("这一篇幅偏理论的概念太多，目前没有太多的时间去看这些。先暂时放置，后续再回顾！！！！")])]),a._v(" "),v("h2",{attrs:{id:"javascript-内存管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javascript-内存管理"}},[a._v("#")]),a._v(" JavaScript 内存管理")]),a._v(" "),v("p",[a._v("JavaScript中内存管理是自动的，内存管理分为三个步骤")]),a._v(" "),v("ul",[v("li",[a._v("申请内存")]),a._v(" "),v("li",[a._v("使用内存")]),a._v(" "),v("li",[a._v("释放内存")])]),a._v(" "),v("h2",{attrs:{id:"javascript-的垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的垃圾回收"}},[a._v("#")]),a._v(" JavaScript 的垃圾回收")]),a._v(" "),v("p",[a._v("可达的概念。")]),a._v(" "),v("ul",[v("li",[a._v("有引用")]),a._v(" "),v("li",[a._v("从全局作用域能访问到")])]),a._v(" "),v("p",[a._v("如果不符合以上两点就会触发"),v("code",[a._v("javascript")]),a._v("垃圾回收，被回收。")]),a._v(" "),v("h2",{attrs:{id:"gc-算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gc-算法"}},[a._v("#")]),a._v(" GC 算法")]),a._v(" "),v("h3",{attrs:{id:"引用技术算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#引用技术算法"}},[a._v("#")]),a._v(" 引用技术算法")]),a._v(" "),v("p",[a._v("当某一个变量被引用一次就加1，如果一个变量被引用次数是0，那就可以直接回收掉了。")]),a._v(" "),v("p",[v("strong",[a._v("缺点")]),a._v("\n循环引用，无法回收。因为循环引用在他内部还有引用，但是已经不可达了。")]),a._v(" "),v("h3",{attrs:{id:"标记清除算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标记清除算法"}},[a._v("#")]),a._v(" 标记清除算法")]),a._v(" "),v("p",[v("strong",[a._v("缺点")]),a._v("\n会有空间碎片化")]),a._v(" "),v("h3",{attrs:{id:"标记整理算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标记整理算法"}},[a._v("#")]),a._v(" 标记整理算法")]),a._v(" "),v("p",[a._v("标记整理算法会将一个原本是乱序的内存空间占用状态，整理成一个有序的状态，首先将活动的内存空间都整理在一起，然后把非活动和空的内存空间整理在一起，然后再释放非活动的内存空间。")])])}),[],!1,null,null,null);t.default=r.exports}}]);