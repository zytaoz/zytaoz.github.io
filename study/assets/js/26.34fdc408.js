(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{387:function(e,t,r){"use strict";r.r(t);var o=r(49),v=Object(o.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"vue-router-源码及实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-源码及实现"}},[e._v("#")]),e._v(" Vue Router 源码及实现")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("写在前面")]),e._v(" "),r("p",[e._v("Vue 可以说是拥有整个前端生态中最友好的官方中文文档，所以熟读文档真的非常重要。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://router.vuejs.org/zh/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue Router v3.x"),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"路由模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#路由模式"}},[e._v("#")]),e._v(" 路由模式")]),e._v(" "),r("p",[r("code",[e._v("Vue Router")]),e._v(" 一共有两种路由模式。")]),e._v(" "),r("h3",{attrs:{id:"hash-模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hash-模式"}},[e._v("#")]),e._v(" Hash 模式")]),e._v(" "),r("p",[r("code",[e._v("hash")]),e._v(" 模式就是链接里面带 "),r("code",[e._v("#")]),e._v("。")]),e._v(" "),r("ul",[r("li",[e._v("而 "),r("code",[e._v("hash")]),e._v(" 模式是基于锚点，即使用 "),r("code",[e._v("url")]),e._v(" 中 "),r("code",[e._v("#")]),e._v(" 后面的链接作为路径参数。")]),e._v(" "),r("li",[e._v("然后通过监听 "),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/WindowEventHandlers/onhashchange",target:"_blank",rel:"noopener noreferrer"}},[e._v("onhashchange"),r("OutboundLink")],1),e._v(" 事件。")]),e._v(" "),r("li",[e._v("匹配渲染当前路由地址的对应组件来实现的。")])]),e._v(" "),r("h3",{attrs:{id:"history-模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#history-模式"}},[e._v("#")]),e._v(" history 模式")]),e._v(" "),r("p",[r("code",[e._v("history")]),e._v(" 模式从链接上看起来就是正常的 "),r("code",[e._v("url")]),e._v(" 链接。")]),e._v(" "),r("ul",[r("li",[e._v("他是通过使用 "),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/History/pushState",target:"_blank",rel:"noopener noreferrer"}},[e._v("History.pushState"),r("OutboundLink")],1),e._v(" 和 "),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/History/replaceState",target:"_blank",rel:"noopener noreferrer"}},[e._v("History.replaceState"),r("OutboundLink")],1),e._v(" 来改变链接地址。")]),e._v(" "),r("li",[e._v("然后监听 "),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event",target:"_blank",rel:"noopener noreferrer"}},[e._v("popstate"),r("OutboundLink")],1),e._v(" 事件。")]),e._v(" "),r("li",[e._v("在监听到 "),r("code",[e._v("url")]),e._v(" 有变化后，去匹配渲染当前路由地址的对应组件。")])]),e._v(" "),r("h4",{attrs:{id:"一个老生常谈的问题。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一个老生常谈的问题。"}},[e._v("#")]),e._v(" 一个老生常谈的问题。")]),e._v(" "),r("p",[r("code",[e._v("history")]),e._v(" 上线之后需要进行服务端配置才能实现路由访问。为什么会这样呢？")]),e._v(" "),r("ul",[r("li",[e._v("首先从浏览器的层面上来说，它并不知道我们访问的这个 "),r("code",[e._v("URL")]),e._v(" 地址是不是一个单页面应用，他只会像服务端请求我们访问的链接地址。")]),e._v(" "),r("li",[e._v("但是因为我们的网站是一个单页面应用，浏览器访问的这个地址其实是不存在的，服务端上的页面链接只有 "),r("code",[e._v("index.html")]),e._v(" 是可以被真实访问到的。")]),e._v(" "),r("li",[e._v("所以，不管是 "),r("code",[e._v("nodejs")]),e._v(" 还是 "),r("code",[e._v("nginx")]),e._v(" 他们做的事情都是一样的。即：不管浏览器请求的是哪一个页面链接，始终只返回 "),r("code",[e._v("index.html")]),e._v(" 入口文件的链接。")])]),e._v(" "),r("h2",{attrs:{id:"实现一个-vue-router"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现一个-vue-router"}},[e._v("#")]),e._v(" 实现一个 Vue Router")])])}),[],!1,null,null,null);t.default=v.exports}}]);